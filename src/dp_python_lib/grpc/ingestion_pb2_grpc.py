# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from . import ingestion_pb2 as ingestion__pb2

GRPC_GENERATED_VERSION = '1.76.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + ' but the generated code in ingestion_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class DpIngestionServiceStub(object):
    """
    ------------------- RPC Interfaces ---------------------------



    The Ingestion Service Interface

    Defines RPC operations for data provider registration and ingestion.

    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.registerProvider = channel.unary_unary(
                '/dp.service.ingestion.DpIngestionService/registerProvider',
                request_serializer=ingestion__pb2.RegisterProviderRequest.SerializeToString,
                response_deserializer=ingestion__pb2.RegisterProviderResponse.FromString,
                _registered_method=True)
        self.ingestData = channel.unary_unary(
                '/dp.service.ingestion.DpIngestionService/ingestData',
                request_serializer=ingestion__pb2.IngestDataRequest.SerializeToString,
                response_deserializer=ingestion__pb2.IngestDataResponse.FromString,
                _registered_method=True)
        self.ingestDataStream = channel.stream_unary(
                '/dp.service.ingestion.DpIngestionService/ingestDataStream',
                request_serializer=ingestion__pb2.IngestDataRequest.SerializeToString,
                response_deserializer=ingestion__pb2.IngestDataStreamResponse.FromString,
                _registered_method=True)
        self.ingestDataBidiStream = channel.stream_stream(
                '/dp.service.ingestion.DpIngestionService/ingestDataBidiStream',
                request_serializer=ingestion__pb2.IngestDataRequest.SerializeToString,
                response_deserializer=ingestion__pb2.IngestDataResponse.FromString,
                _registered_method=True)
        self.queryRequestStatus = channel.unary_unary(
                '/dp.service.ingestion.DpIngestionService/queryRequestStatus',
                request_serializer=ingestion__pb2.QueryRequestStatusRequest.SerializeToString,
                response_deserializer=ingestion__pb2.QueryRequestStatusResponse.FromString,
                _registered_method=True)
        self.subscribeData = channel.stream_stream(
                '/dp.service.ingestion.DpIngestionService/subscribeData',
                request_serializer=ingestion__pb2.SubscribeDataRequest.SerializeToString,
                response_deserializer=ingestion__pb2.SubscribeDataResponse.FromString,
                _registered_method=True)


class DpIngestionServiceServicer(object):
    """
    ------------------- RPC Interfaces ---------------------------



    The Ingestion Service Interface

    Defines RPC operations for data provider registration and ingestion.

    """

    def registerProvider(self, request, context):
        """
        registerProvider(): Data provider registration.

        This unary method sends a single RegisterProviderRequest and receives a single RegisterProviderResponse.  It is
        required to call this method to register a data provider before calling one of the data ingestion methods using
        the id of that provider.

        Provider name is required in the RegisterProviderRequest, which may also contain optional descriptive fields.

        The response message indicates whether or not the registration was successful.  The response payload is an
        ExceptionalResult if the request is unsuccessful, otherwise it is a RegistrationResult that includes details about
        the new provider including providerId (for use in calls to data ingestion methods) and a flag indicating if the
        provider is new.  On success, if a document already exists in the MongoDB "providers" collection for the provider
        name specified in the RegisterProviderRequest, the method returns the corresponding provider id in the response,
        otherwise a new document is created in the "providers" collection and its id returned in the response.

        It is safe (and recommended) to call this method each time a data ingestion client is run.  If a document already
        exists in the MongoDB providers collection for the specified provider, the attributes are updated to the values in
        the RegisterProviderRequest.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ingestData(self, request, context):
        """
        ingestData(): Unary (non-streaming) data ingestion.

        This method sends a single IngestDataRequest and receives a single IngestDataResponse.  Validation,
        rejection / acknowledgment, asynchronous handling, and request status reporting is otherwise the same as for the
        ingestDataBidiStream() method.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ingestDataStream(self, request_iterator, context):
        """
        ingestDataStream(): Unidirectional client-side streaming data ingestion.

        This client-side streaming ingestion method sends a stream of IngestDataRequest messages and receives a single
        IngestDataStreamResponse. Validation, rejection / acknowledgment, asynchronous handling, and request status
        reporting is otherwise the same as for the ingestDataBidiStream() method, with the only difference being that
        there is a single summary response message for the request stream instead of a stream of individual responses to
        each request message.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ingestDataBidiStream(self, request_iterator, context):
        """
        ingestDataBidiStream(): Bidirectional streaming data ingestion.

        The Ingestion Service performs initial validation on each IngestDataRequest in the stream, and replies immediately
        with a IngestDataResponse message indicating acknowledgement for a valid request, or rejection of an invalid one.
        The request is then added to a queue for async ingestion handling.

        The ingestion handling of each request in the stream is performed asynchronously.  The Ingestion Service writes
        data from the request to the "buckets" collection in MongoDB, adding one document to the collection for each
        "column" of data in the request's DataFrame object.

        A separate MongoDB "requestStatus" collection is used to note the processing status of each request,
        with a document for each handled request.  The collection is keyed by the providerId and clientRequestId
        specified in the IngestDataRequest.  This collection can be used by an administrative monitoring process
        to detect and notify about errors in the ingestion process.

        The method returns a stream of IngestDataResponse messages, one per request.  Each response includes providerId
        and clientRequestId for use by the client in mapping a response to the corresponding request.  The response
        message only indicates if validation succeeded or failed.  Because ingestion handling is performed asynchronously,
        the MongoDB "requestStatus" collection must be used to determine the success or failure of individual requests.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def queryRequestStatus(self, request, context):
        """
        queryRequestStatus(): Ingestion request status query.

        This unary method sends a single QueryRequestStatusRequest and receives a single QueryRequestStatusResponse.  It
        is used to determine the status of an individual data ingestion request, or to find data ingestion errors for a
        specified time range.

        The QueryRequestStatusRequest message contains a list of criteria for searching by provider id, provider name,
        request id, status, and time range. The criteria can be combined arbitrarily, but we envision three primary use
        cases:

        1) Query by provider id or name and request id to find the status of a specific ingestion request.
        2) Query by provider id or name, status (e.g., rejected or error) and time range.
        3) Query by status and time range without specifying a provider (e.g., "find all ingestion errors for today").

        The QueryRequestStatusResponse message payload is either an ExceptionalResult containing details about a
        rejection or error, or a RequestStatusResult containing a list of RequestStatus messages, one for each document
        in the MongoDB "requestStatus" collection that matches the search criteria.

        Each RequestStatus message contains details about the status of an individual ingestion request, including
        provider id/name, request id, status enum, status message, and list of bucket ids created (documents added to the
        MongoDB "buckets" collection).
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def subscribeData(self, request_iterator, context):
        """
        subscribeData(): Register a subscription for new data received in the ingestion stream.

        This method allows the client to register a subscription for a list of PVs, and receive new data for those PVs
        received by the Ingestion Service after the subscription is created.  The method uses bidirectional streaming.
        The client sends SubscribeDataRequest messages in the method's request stream, and receives SubscribeDataResponse
        messages in the response stream.

        To initiate a new subscription, the client sends a single SubscribeDataRequest message (containing a
        NewSubscription message payload) to register the new subscription.

        The service responds with a single SubscribeDataResponse message, containing either an ExceptionalResult message
        payload if the request is rejected by the service or an AckResult message if the service accepts the request and
        registers the subscription.

        The service then sends a stream of SubscribeDataResponse messages, each containing a SubscribeDataResult with
        published data for the registered PVs, until the client cancels the subscription, either by sending a
        SubscribeDataRequest containing a CancelSubscription payload or by closing the API method's request stream.

        The service sends a response with an ExceptionalResult payload if it rejects the subscription request or an error
        occurs while handling the subscription.  In either case, after sending the ExceptionalResult message the service
        closes the API method response stream.

        If the client sends subsequent NewSubscription messages after registering the initial subscription, the service
        sends a reject message and closes the response stream.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_DpIngestionServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'registerProvider': grpc.unary_unary_rpc_method_handler(
                    servicer.registerProvider,
                    request_deserializer=ingestion__pb2.RegisterProviderRequest.FromString,
                    response_serializer=ingestion__pb2.RegisterProviderResponse.SerializeToString,
            ),
            'ingestData': grpc.unary_unary_rpc_method_handler(
                    servicer.ingestData,
                    request_deserializer=ingestion__pb2.IngestDataRequest.FromString,
                    response_serializer=ingestion__pb2.IngestDataResponse.SerializeToString,
            ),
            'ingestDataStream': grpc.stream_unary_rpc_method_handler(
                    servicer.ingestDataStream,
                    request_deserializer=ingestion__pb2.IngestDataRequest.FromString,
                    response_serializer=ingestion__pb2.IngestDataStreamResponse.SerializeToString,
            ),
            'ingestDataBidiStream': grpc.stream_stream_rpc_method_handler(
                    servicer.ingestDataBidiStream,
                    request_deserializer=ingestion__pb2.IngestDataRequest.FromString,
                    response_serializer=ingestion__pb2.IngestDataResponse.SerializeToString,
            ),
            'queryRequestStatus': grpc.unary_unary_rpc_method_handler(
                    servicer.queryRequestStatus,
                    request_deserializer=ingestion__pb2.QueryRequestStatusRequest.FromString,
                    response_serializer=ingestion__pb2.QueryRequestStatusResponse.SerializeToString,
            ),
            'subscribeData': grpc.stream_stream_rpc_method_handler(
                    servicer.subscribeData,
                    request_deserializer=ingestion__pb2.SubscribeDataRequest.FromString,
                    response_serializer=ingestion__pb2.SubscribeDataResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'dp.service.ingestion.DpIngestionService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('dp.service.ingestion.DpIngestionService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class DpIngestionService(object):
    """
    ------------------- RPC Interfaces ---------------------------



    The Ingestion Service Interface

    Defines RPC operations for data provider registration and ingestion.

    """

    @staticmethod
    def registerProvider(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dp.service.ingestion.DpIngestionService/registerProvider',
            ingestion__pb2.RegisterProviderRequest.SerializeToString,
            ingestion__pb2.RegisterProviderResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ingestData(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dp.service.ingestion.DpIngestionService/ingestData',
            ingestion__pb2.IngestDataRequest.SerializeToString,
            ingestion__pb2.IngestDataResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ingestDataStream(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_unary(
            request_iterator,
            target,
            '/dp.service.ingestion.DpIngestionService/ingestDataStream',
            ingestion__pb2.IngestDataRequest.SerializeToString,
            ingestion__pb2.IngestDataStreamResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ingestDataBidiStream(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/dp.service.ingestion.DpIngestionService/ingestDataBidiStream',
            ingestion__pb2.IngestDataRequest.SerializeToString,
            ingestion__pb2.IngestDataResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def queryRequestStatus(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/dp.service.ingestion.DpIngestionService/queryRequestStatus',
            ingestion__pb2.QueryRequestStatusRequest.SerializeToString,
            ingestion__pb2.QueryRequestStatusResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def subscribeData(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/dp.service.ingestion.DpIngestionService/subscribeData',
            ingestion__pb2.SubscribeDataRequest.SerializeToString,
            ingestion__pb2.SubscribeDataResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
